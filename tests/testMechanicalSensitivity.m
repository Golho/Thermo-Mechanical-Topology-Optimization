clear; close all;
timeSteps = 1;
volumeFraction = 0.4;
radius = 0.025;

material_1 = Material(1, 1e6, 0.1*eye(3), 1e1, 0.25, 0);
material_2 = Material(2, 1e6, 10*eye(3), 1e9, 0.25, 5e-5);

materials = [material_1, material_2];
%% Structured mesh
isnear = @(x, a) abs(x-a) < 1e-3;
mesh = StructuredMesh([5, 0.1], [5, 0.1]);
globalCoord = mesh.coordinates();

centerNodes = find( (globalCoord(1, :) >= 0.046 & globalCoord(1, :) <= 0.054) & ...
                    (globalCoord(2, :) >= 0.046 & globalCoord(2, :) <= 0.054));
                
cornerNodes = find( (isnear(globalCoord(1, :), 0) | isnear(globalCoord(1, :), 0.1)) & ...
                    (isnear(globalCoord(2, :), 0) | isnear(globalCoord(2, :), 0.1)));

% Create boundary conditions
prescribed = struct(...
    'nodes', cornerNodes, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [1, 1], ...
    'timeSteps', 1:timeSteps ...
);

centerForce = struct(...
    'nodes', centerNodes, ...
    'type', 'Neumann', ...
    'value', 1/length(centerNodes), ...
    'components', [0, 1], ...
    'timeSteps', 1:timeSteps ...
);

% Create body conditions
body = struct(...
    'type', 'main' ...
);

fem = OptMechFEMStructured(numel(materials), mesh, timeSteps, "plane stress");

fem.addBoundaryCondition(prescribed);
fem.addBoundaryCondition(centerForce);
fem.addBodyCondition(body);

temps = 20*ones(size(fem.temperatureChanges));
fem.setTemperatures(temps);

fem.setMaterial(material_2);
[E, EDer, alpha, alphaDer] = MechSIMP(materials, 3, 3);
fem.addInterpFuncs(E, EDer, alpha, alphaDer);

options = struct(...
    "heavisideFilter", false, ...
    'designFilter', true, ...
    'filterRadius', radius, ...
    'filterWeightFunction', @(dx, dy, dz) max(radius-sqrt(dx.^2+dy.^2+dz.^2), 0), ...
    'materials', materials, ...
    'plot', false ...
);
%%
massLimit = volumeFraction * sum(fem.volumes*material_2.density);

topOpt = MechComplianceProblem(fem, options, massLimit);
initial = rand(size(fem.designPar));
g(1) = topOpt.objective(initial)

errors = topOpt.testGradients(initial, 1e-6)
assert(all(errors < 1e-5), "Sensitivities does not match");
%%
leftCenterNode = find(globalCoord(1, :) == 0 & ...
                     (globalCoord(2, :) >= 0.046 & globalCoord(2, :) <= 0.054));

output = struct(...
    'nodes', leftCenterNode, ...
    'type', 'dummy', ...
    'name', 'josse', ...
    'value', -1, ...
    'components', [1, 0], ...
    'timeSteps', 1:timeSteps ...
);

spring = struct(...
    'nodes', leftCenterNode, ...
    'type', 'Robin', ...
    'value', 1e5, ...
    'components', [1, 0], ...
    'timeSteps', 1:timeSteps ...
);

fem.addBoundaryCondition(output);
fem.addBoundaryCondition(spring);
%%
topOpt = FlexibilityProblem(fem, options, massLimit, 0.0005);
initial = rand(size(fem.designPar));
g(1) = topOpt.objective(initial)

errors = topOpt.testGradients(initial, 1e-6)
assert(all(errors < 1e-5), "Sensitivities does not match");
%%
%This problem is very sensitive and is therefore not included in the tests
% topOpt = FlexibilityProblem2(fem, options, 0.4);
% initial = rand(size(fem.designPar));
% g(1) = topOpt.objective(initial)
% 
% errors = topOpt.testGradients(initial, 1e-6)
% assert(all(errors < 1e-5), "Sensitivities does not match");