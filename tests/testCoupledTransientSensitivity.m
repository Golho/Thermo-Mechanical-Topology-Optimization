clear; close all;

opt.maxtime = 15*60;
opt.verbose = 1;
opt.ftol_rel = 1e-7;
%opt.xtol_abs = 1e-7*ones(size(fem.mainDensities));
opt.algorithm = NLOPT_LD_MMA;

timeSteps = 50;
volumeFraction = 0.25;
radius = 0.002;
u_max = 1e-6;
P = 1;
k = 0;
tFinal = 20000;
angle = pi/4;

dummyName = "josse";

material_1 = Material(1, 1.767e6, 1e-3*eye(3), 3e2, 0.45, 0);
material_2 = Material(1, 1.767e6, 0.33*eye(3), 0.2e9, 0.45, 230e-6);

materials = [material_1, material_2];
%%
width = 0.1;
height = 0.1;
mesh = StructuredMesh([11, width], [11, height]);
globalCoord = mesh.coordinates();


topAndLeftNodes = find(globalCoord(1, :) == 0 | ...
    globalCoord(2, :) == height);
topRightNode = find(globalCoord(1, :) == height & globalCoord(2, :) == width);
topCornerExpanded = find(globalCoord(2, :) == height & ...
    globalCoord(1, :) <= width/25);
bottomNodes = find(globalCoord(2, :) == 0);
rightCornerExpanded = find((globalCoord(1, :) >= width*9/10 & globalCoord(2, :) == 0) | ...
                           (globalCoord(2, :) <= height/10 & globalCoord(1, :) == width));
rightCorner = find(globalCoord(1, :) >= width*9/10 & globalCoord(2, :) == 0);

% Create boundary conditions
fixed = struct(...
    'nodes', rightCornerExpanded, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [1, 0], ...
    'timeSteps', 1:timeSteps ...
);

symmetry = struct(...
    'nodes', bottomNodes, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [0, 1], ...
    'timeSteps', 1:timeSteps ...
);

output = struct( ...
    'nodes', topRightNode, ...
    'type', 'dummy', ...
    'name', dummyName, ...
    'value', 0.001, ...
    'components', [1, 0], ...
    'timeSteps', floor(timeSteps/2) ...
);

output2 = struct( ...
    'nodes', topRightNode, ...
    'type', 'dummy', ...
    'name', dummyName, ...
    'value', eps, ...
    'components', [1, 0], ...
    'timeSteps', timeSteps ...
);

spring = struct( ...
    'nodes', topRightNode, ...
    'type', 'Robin', ...
    'value', k, ...
    'components', [1, 0], ...
    'timeSteps', 1:timeSteps ...
);

tempPrescribed = struct( ...
    'nodes', rightCorner, ...
    'type', 'Dirichlet', ...
    'value', 100, ...
    'timeSteps', 1:timeSteps ...
);


% Create body conditions
body = struct(...
    'type', 'main' ...
);

stiffFEM = OptMechFEMStructured(numel(materials), mesh, 1, "plane stress");

fixed2 = struct(...
    'nodes', rightCornerExpanded, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [1, 0], ...
    'timeSteps', 1 ...
);

symmetry2 = struct(...
    'nodes', bottomNodes, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [0, 1], ...
    'timeSteps', 1 ...
);

retention = struct( ...
    'nodes', topRightNode, ...
    'type', 'Neumann', ...
    'value', 1, ...
    'components', [1, 0], ...
    'timeSteps', 1 ...
);

stiffFEM.addBoundaryCondition(fixed2);
stiffFEM.addBoundaryCondition(symmetry2);
stiffFEM.addBoundaryCondition(retention);
stiffFEM.addBodyCondition(body);

stiffFEM.setMaterial(material_2);

mechFEM = OptMechFEMStructured(numel(materials), mesh, timeSteps, "plane stress");

mechFEM.addBoundaryCondition(fixed);
mechFEM.addBoundaryCondition(symmetry);
mechFEM.addBoundaryCondition(output);
mechFEM.addBoundaryCondition(output2);
mechFEM.addBoundaryCondition(spring);
mechFEM.addBodyCondition(body);

mechFEM.setMaterial(material_2);

options = struct(...
    'heavisideFilter', false, ...
    'designFilter', true, ...
    'filterRadius', radius, ...
    'filterWeightFunction', @(dx, dy, dz) max(radius-sqrt(dx.^2+dy.^2+dz.^2), 0), ...
    'materials', materials, ...
    'plot', false ...
);


%%
p_kappa = 3;
p_cp = 1;
p_E = 3;
p_alpha = 3;
mechFEM_i = copy(mechFEM);

heatFEM_i = OptThermoMechStructured(mechFEM_i, numel(materials), mesh, tFinal, timeSteps, 1);

heatFEM_i.addBoundaryCondition(tempPrescribed);
heatFEM_i.addBodyCondition(body);

heatFEM_i.setMaterial(material_2);
stiffFEM.setMaterial(material_2);

[E, EDer, alpha, alphaDer] = MechSIMP(materials, p_E, p_alpha);
stiffFEM.addInterpFuncs(E, EDer, alpha, alphaDer);
mechFEM_i.addInterpFuncs(E, EDer, alpha, alphaDer);

[kappaF, kappaFDer, cp, cpDer] = HeatSIMP(materials, p_kappa, p_cp);
heatFEM_i.addInterpFuncs(kappaF, kappaFDer, cp, cpDer);

coupledFEM = heatFEM_i;
%%
massLimit = volumeFraction * sum(heatFEM_i.volumes*material_2.density);

topOpt = ThermallyActuatedProblemTransient(coupledFEM, stiffFEM, dummyName, options, massLimit, u_max);
designPar = 0.5*ones(size(heatFEM_i.designPar));
g(1) = topOpt.objective(designPar)

% Numerical gradient
dgdphi = numGrad(@topOpt.objective, designPar, 1e-8);

% Analytical gradient
der_g = topOpt.gradObjective(designPar);
norm(dgdphi - der_g) / norm(dgdphi)
assert(norm(dgdphi - der_g) / norm(dgdphi) < 1e-5, "Sensitivities does not match");