clear; close all;

jobManager = JobManager();

opt.maxtime = 5*60;
opt.verbose = 1;
opt.ftol_rel = 1e-6;
%opt.xtol_abs = 1e-7*ones(size(fem.mainDensities));
opt.algorithm = NLOPT_LD_MMA;

timeSteps = 1;
volumeFraction = 0.3;
radius = 0.01;
u_max = 5e-6;
P = 1;
k = 1e7;

void = Material(0, 1e6, 0.1*eye(3), 3e-2, 0.4);
material_1 = Material(1.5e3, 1e3, 10*eye(3), 5e9, 0.4);
material_2 = Material(1e3, 1e3, 10*eye(3), 3e9, 0.4);
materials = [void, material_1, material_2];
%% Structured mesh
isnear = @(x, a) abs(x-a) < 1e-3;
width = 0.3;
height = 0.1;
mesh = StructuredMesh([41, width], [21, height]);
globalCoord = mesh.coordinates();

topCornerNode = find(globalCoord(2, :) == height & globalCoord(1, :) == 0);
leftNodes = find(globalCoord(1, :) == 0);
leftTopCornerNode = find(globalCoord(1, :) == 0 & globalCoord(2, :) == height);
bottomRightCornerNode = find(globalCoord(2, :) == 0 & globalCoord(1, :) == width);

topAndLeftNodes = find(globalCoord(1, :) == 0 | ...
    globalCoord(2, :) == height);
topCornerExpanded = find(globalCoord(2, :) == height & ...
    globalCoord(1, :) <= width/25);
rightCornerExpanded = find(globalCoord(1, :) == width & globalCoord(2, :) < height/25);

% Create boundary conditions
fixed = struct(...
    'nodes', bottomRightCornerNode, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [0, 1], ...
    'timeSteps', 1:timeSteps ...
);

symmetry = struct(...
    'nodes', leftNodes, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [1, 0], ...
    'timeSteps', 1:timeSteps ...
);

pointLoad = struct(...
    'nodes', topCornerNode, ...
    'type', 'Neumann', ...
    'value', -10000, ...
    'components', [0, 1], ...
    'timeSteps', 1:timeSteps ...
);

% Create body conditions
body = struct(...
    'type', 'main' ...
);

fem = OptMechFEMStructured(numel(materials), mesh, timeSteps, "plane stress");

fem.addBoundaryCondition(fixed);
fem.addBoundaryCondition(symmetry);
fem.addBoundaryCondition(pointLoad);
fem.addBodyCondition(body);
fem.setMaterial(material_1);

[E, EDer, alpha, alphaDer] = MechSIMP(materials, 3, 3);
fem.addInterpFuncs(E, EDer, alpha, alphaDer);


options = struct(...
    'heavisideFilter', false, ...
    'designFilter', true, ...
    'filterRadius', radius, ...
    'filterWeightFunction', @(dx, dy, dz) max(radius-sqrt(dx.^2+dy.^2+dz.^2), 0), ...
    'materials', materials, ...
    'plot', false ...
);
massLimit = volumeFraction * sum(fem.volumes*material_1.density);
initial = zeros(size(fem.designPar));
initial(1, :) = volumeFraction;
%%
topOpt = MechComplianceProblem(fem, options, massLimit);

job = Job(topOpt, initial, opt);
jobManager.add(job);
%%
topLeftNodes = find(globalCoord(1, :) == 0 & globalCoord(2, :) <= 0.1 &  ...
    globalCoord(2, :) >= 0.075);
bottomNodes = find(globalCoord(2, :) == 0);
bottomLeftNode = find(globalCoord(1, :) == 0 & globalCoord(2, :) == 0);
bottomRightNode = find(globalCoord(1, :) == 0.3 & globalCoord(2, :) == 0);
topRightNode = find(globalCoord(1, :) == 0.3 & globalCoord(2, :) == 0.1);


% Create boundary conditions
fixed = struct(...
    'nodes', topLeftNodes, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [1, 1], ...
    'timeSteps', 1:timeSteps ...
);

symmetry = struct(...
    'nodes', bottomNodes, ...
    'type', 'Dirichlet', ...
    'value', 0, ...
    'components', [0, 1], ...
    'timeSteps', 1:timeSteps ...
);

pointLoad = struct(...
    'nodes', topRightNode, ...
    'type', 'Neumann', ...
    'value', -P, ...
    'components', [0, 1], ...
    'timeSteps', 1:timeSteps ...
);

pointLoad2 = struct(...
    'nodes', bottomRightNode, ...
    'type', 'Neumann', ...
    'value', -P, ...
    'components', [1, 0], ...
    'timeSteps', 1:timeSteps ...
);


spring = struct(...
    'nodes', bottomLeftNode, ...
    'type', 'Robin', ...
    'value', k, ...
    'components', [1, 0], ...
    'timeSteps', 1:timeSteps ...
);

output = struct(...
    'nodes', bottomLeftNode, ...
    'type', 'dummy', ...
    'name', 'josse', ...
    'value', -1e3, ...
    'components', [1, 0], ...
    'timeSteps', 1:timeSteps ...
);

fem = OptMechFEMStructured(numel(materials), mesh, timeSteps, "plane stress");

fem.addBoundaryCondition(fixed);
fem.addBoundaryCondition(symmetry);
fem.addBoundaryCondition(pointLoad);
fem.addBoundaryCondition(spring);
fem.addBoundaryCondition(output);
fem.addBodyCondition(body);

fem.setMaterial(material_1);
[E, EDer, alpha, alphaDer] = MechSIMP(materials, [4, 6], [3, 3]);
fem.addInterpFuncs(E, EDer, alpha, alphaDer);


options = struct(...
    'heavisideFilter', false, ...
    'designFilter', true, ...
    'filterRadius', radius, ...
    'filterWeightFunction', @(dx, dy, dz) max(radius-sqrt(dx.^2+dy.^2+dz.^2), 0), ...
    'materials', materials, ...
    'plot', false ...
);

massLimit = volumeFraction * sum(fem.volumes*material_1.density);
initial = zeros(size(fem.designPar));
initial(1, :) = volumeFraction;

topOpt = FlexibilityProblem(fem, options, massLimit, u_max);

job = Job(topOpt, initial, opt);
jobManager.add(job);
%%
topOpt = FlexibilityProblem2(copy(fem), options, volumeFraction);

job = Job(topOpt, initial, opt);
% Comment out the non-constrained flexibility problem, as it is too
% sensitive
%jobManager.add(job);
%%
jobManager.runAll();
%%
jobManager.plotAll();